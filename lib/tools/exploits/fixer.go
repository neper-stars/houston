package exploits

import (
	"encoding/binary"
	"fmt"

	"github.com/neper-stars/houston/blocks"
	"github.com/neper-stars/houston/crypto"
	"github.com/neper-stars/houston/parser"
)

// Fixer applies fixes for detected exploits.
type Fixer struct {
	modified bool
}

// NewFixer creates a new exploit fixer.
func NewFixer() *Fixer {
	return &Fixer{}
}

// FixFile scans and fixes exploits in a file.
// Returns the fixed file data and the scan result.
func (f *Fixer) FixFile(filename string, data []byte) ([]byte, *Result, error) {
	fd := parser.FileData(data)

	header, err := fd.FileHeader()
	if err != nil {
		return nil, nil, fmt.Errorf("failed to get file header: %w", err)
	}

	blockList, err := fd.BlockList()
	if err != nil {
		return nil, nil, fmt.Errorf("failed to parse blocks: %w", err)
	}

	scanner := NewScanner()

	// Track player from the file
	playerIndex := 0
	if header != nil {
		playerIndex = header.PlayerIndex()
	}

	// First pass: scan for exploits
	for i, blk := range blockList {
		switch b := blk.(type) {
		case blocks.DesignBlock:
			scanner.processDesign(&b, playerIndex, i)
		case *blocks.DesignBlock:
			scanner.processDesign(b, playerIndex, i)
		case blocks.DesignChangeBlock:
			scanner.processDesignChange(&b, playerIndex, i)
		case *blocks.DesignChangeBlock:
			scanner.processDesignChange(b, playerIndex, i)
		case blocks.FleetBlock:
			scanner.processFleet(&b.PartialFleetBlock)
		case *blocks.FleetBlock:
			scanner.processFleet(&b.PartialFleetBlock)
		case blocks.PartialFleetBlock:
			scanner.processFleet(&b)
		case *blocks.PartialFleetBlock:
			scanner.processFleet(b)
		case blocks.BattlePlanBlock:
			scanner.processBattlePlan(&b, i)
		case *blocks.BattlePlanBlock:
			scanner.processBattlePlan(b, i)
		case blocks.ProductionQueueBlock:
			scanner.processProductionQueue(&b, playerIndex)
		case *blocks.ProductionQueueBlock:
			scanner.processProductionQueue(b, playerIndex)
		case blocks.ProductionQueueChangeBlock:
			scanner.processProductionQueueChange(&b, playerIndex)
		case *blocks.ProductionQueueChangeBlock:
			scanner.processProductionQueueChange(b, playerIndex)
		case blocks.WaypointChangeTaskBlock:
			scanner.processWaypointChangeTask(&b, playerIndex, i)
		case *blocks.WaypointChangeTaskBlock:
			scanner.processWaypointChangeTask(b, playerIndex, i)
		}
	}

	result := scanner.Result()

	// Second pass: apply fixes
	f.modified = false
	for _, detection := range result.Detections {
		if !detection.CanFix {
			continue
		}

		if detection.BlockIndex < 0 || detection.BlockIndex >= len(blockList) {
			continue
		}

		blk := blockList[detection.BlockIndex]
		fixed := false

		switch detection.Type {
		case ExploitCheapColonizer:
			fixed = f.fixCheapColonizer(blk)

		case ExploitSpaceDockOverflow:
			fixed = f.fixSpaceDockOverflow(blk)

		case ExploitFriendlyFire:
			fixed = f.fixFriendlyFire(blk)

		case ExploitSSPopSteal:
			fixed = f.fixSSPopSteal(blk)

		case Exploit32kMerge:
			fixed = f.fix32kMerge(blk)

		case ExploitCheapStarbase:
			fixed = f.fixCheapStarbase(blk)
		}

		if fixed {
			detection.FixApplied = true
			f.modified = true
		}
	}

	// If no modifications, return original data
	if !f.modified {
		return data, result, nil
	}

	// Regenerate the file with fixed blocks
	fixedData, err := regenerateFile(data, blockList, header)
	if err != nil {
		return nil, result, fmt.Errorf("failed to regenerate file: %w", err)
	}

	return fixedData, result, nil
}

// fixCheapColonizer fixes the Cheap Colonizer exploit by clearing the category.
func (f *Fixer) fixCheapColonizer(blk blocks.Block) bool {
	var data []byte
	var offset int

	switch b := blk.(type) {
	case blocks.DesignBlock:
		data = b.Decrypted
		offset = 17
	case *blocks.DesignBlock:
		data = b.Decrypted
		offset = 17
	case blocks.DesignChangeBlock:
		data = b.Decrypted
		offset = 19
	case *blocks.DesignChangeBlock:
		data = b.Decrypted
		offset = 19
	default:
		return false
	}

	if len(data) < offset {
		return false
	}

	slotCount := int(data[6])
	if _, ok := blk.(blocks.DesignChangeBlock); ok {
		slotCount = int(data[8])
	}
	if _, ok := blk.(*blocks.DesignChangeBlock); ok {
		slotCount = int(data[8])
	}

	fixed := false

	for i := 0; i < slotCount; i++ {
		slotOffset := offset + (i * 4)
		if slotOffset+4 > len(data) {
			break
		}

		category := binary.LittleEndian.Uint16(data[slotOffset:])
		itemId := data[slotOffset+2]
		count := data[slotOffset+3]

		// Empty colonizer slot: category=4096, itemId=0, count=0
		if category == 4096 && itemId == 0 && count == 0 {
			// Clear the category to truly empty the slot
			binary.LittleEndian.PutUint16(data[slotOffset:], 0)
			fixed = true
		}
	}

	return fixed
}

// fixSpaceDockOverflow fixes the Space Dock Overflow by limiting SuperLatanium to 21.
func (f *Fixer) fixSpaceDockOverflow(blk blocks.Block) bool {
	var data []byte
	var offset int

	switch b := blk.(type) {
	case blocks.DesignBlock:
		data = b.Decrypted
		offset = 17
	case *blocks.DesignBlock:
		data = b.Decrypted
		offset = 17
	case blocks.DesignChangeBlock:
		data = b.Decrypted
		offset = 19
	case *blocks.DesignChangeBlock:
		data = b.Decrypted
		offset = 19
	default:
		return false
	}

	if len(data) < offset {
		return false
	}

	slotCount := int(data[6])
	if _, ok := blk.(blocks.DesignChangeBlock); ok {
		slotCount = int(data[8])
	}
	if _, ok := blk.(*blocks.DesignChangeBlock); ok {
		slotCount = int(data[8])
	}

	fixed := false

	for i := 0; i < slotCount; i++ {
		slotOffset := offset + (i * 4)
		if slotOffset+4 > len(data) {
			break
		}

		category := binary.LittleEndian.Uint16(data[slotOffset:])
		itemId := data[slotOffset+2]
		count := data[slotOffset+3]

		// SuperLatanium: category=8, itemId=11
		if category == 8 && itemId == 11 && count > 21 {
			// Limit to 21
			data[slotOffset+3] = 21
			fixed = true

			// Recalculate armor value (bytes 4-5 for DesignBlock, 6-7 for DesignChangeBlock)
			armorOffset := 4
			if offset == 19 {
				armorOffset = 6
			}
			// Formula: 250 + (1500 * 21) / 2 = 250 + 15750 = 16000
			newArmor := uint16(250 + (1500*21)/2)
			binary.LittleEndian.PutUint16(data[armorOffset:], newArmor)
		}
	}

	return fixed
}

// fixFriendlyFire fixes the Friendly Fire exploit by resetting attack target.
func (f *Fixer) fixFriendlyFire(blk blocks.Block) bool {
	var data []byte

	switch b := blk.(type) {
	case blocks.BattlePlanBlock:
		data = b.Decrypted
	case *blocks.BattlePlanBlock:
		data = b.Decrypted
	default:
		return false
	}

	if len(data) < 4 {
		return false
	}

	// AttackWho is in the high byte of word1 (bytes 2-3)
	// Reset to 2 (Neutrals & Enemies)
	data[3] = 2

	return true
}

// fixSSPopSteal fixes the SS Pop Steal exploit by clearing population transport.
func (f *Fixer) fixSSPopSteal(blk blocks.Block) bool {
	var data []byte

	switch b := blk.(type) {
	case blocks.WaypointChangeTaskBlock:
		data = b.Decrypted
	case *blocks.WaypointChangeTaskBlock:
		data = b.Decrypted
	default:
		return false
	}

	if len(data) < 20 {
		return false
	}

	// Population transport order is at bytes 18-19 (colonists = index 3, each order is 2 bytes)
	// Starting at byte 12: iron(2), boranium(2), germanium(2), population(2)
	// Population is at offset 12 + 6 = 18
	data[18] = 0 // Clear value
	data[19] = 0 // Clear action

	return true
}

// fix32kMerge fixes the 32k Merge exploit by clearing the task.
func (f *Fixer) fix32kMerge(blk blocks.Block) bool {
	var data []byte

	switch b := blk.(type) {
	case blocks.WaypointChangeTaskBlock:
		data = b.Decrypted
	case *blocks.WaypointChangeTaskBlock:
		data = b.Decrypted
	default:
		return false
	}

	if len(data) < 11 {
		return false
	}

	// Clear the task (right 4 bits of byte 10)
	data[10] = data[10] & 0xF0

	return true
}

// fixCheapStarbase fixes the Cheap Starbase exploit by clearing design slots.
func (f *Fixer) fixCheapStarbase(blk blocks.Block) bool {
	var data []byte

	switch b := blk.(type) {
	case blocks.DesignChangeBlock:
		data = b.Decrypted
	case *blocks.DesignChangeBlock:
		data = b.Decrypted
	default:
		return false
	}

	if len(data) < 21 {
		return false
	}

	// Clear all design slots (starting at byte 19 for DesignChangeBlock)
	// Each slot is 4 bytes
	slotCount := int(data[8]) // Slot count is at offset 6 + 2 = 8 in DesignChangeBlock
	offset := 19

	for i := 0; i < slotCount; i++ {
		slotOffset := offset + (i * 4)
		if slotOffset+4 > len(data) {
			break
		}

		// Clear category, itemId, count
		binary.LittleEndian.PutUint16(data[slotOffset:], 0)
		data[slotOffset+2] = 0
		data[slotOffset+3] = 0
	}

	return true
}

// regenerateFile regenerates the file from parsed blocks.
func regenerateFile(originalData []byte, blockList []blocks.Block, header *blocks.FileHeader) ([]byte, error) {
	var result []byte

	offset := 0

	// Initialize encryptor once - it maintains state across blocks
	var encryptor *crypto.Encryptor
	encryptorInitialized := false

	for _, blk := range blockList {
		typeID := blk.BlockTypeID()
		decrypted := blk.DecryptedData()

		if typeID == blocks.FileHeaderBlockType {
			// Header is not encrypted - use raw data length for block header
			blockHeader := (uint16(typeID) << 10) | uint16(len(blk.BlockData()))
			result = append(result, byte(blockHeader), byte(blockHeader>>8))
			result = append(result, blk.BlockData()...)

			// Initialize encryptor from header for subsequent blocks
			if header != nil {
				var sw int
				if header.Shareware() {
					sw = 1
				}
				encryptor = crypto.NewEncryptor()
				encryptor.InitEncryption(header.Salt(), int(header.GameID), int(header.Turn), header.PlayerIndex(), sw)
				encryptorInitialized = true
			}
		} else if typeID == blocks.FileFooterBlockType {
			// Footer is not encrypted
			blockHeader := (uint16(typeID) << 10) | uint16(len(blk.BlockData()))
			result = append(result, byte(blockHeader), byte(blockHeader>>8))
			result = append(result, blk.BlockData()...)
		} else {
			// Regular blocks - use decrypted length for block header
			blockHeader := (uint16(typeID) << 10) | uint16(len(decrypted))
			result = append(result, byte(blockHeader), byte(blockHeader>>8))
			// Re-encrypt the block using the Encryptor
			if encryptorInitialized {
				encrypted := encryptor.EncryptBytes(decrypted)
				result = append(result, encrypted...)
			} else {
				// No encryptor, just copy the decrypted data (shouldn't happen)
				result = append(result, decrypted...)
			}
		}

		offset += 2 + len(blk.BlockData())

		// Handle PlanetsBlock special case - it has extra data tacked on
		if typeID == blocks.PlanetsBlockType {
			if pb, ok := blk.(blocks.PlanetsBlock); ok {
				planetCount := pb.GetPlanetCount()
				if planetCount > 0 {
					// Copy the planet data from original file
					planetDataLen := planetCount * 4
					originalOffset := offset
					if originalOffset+planetDataLen <= len(originalData) {
						result = append(result, originalData[originalOffset:originalOffset+planetDataLen]...)
					}
				}
			} else if pb, ok := blk.(*blocks.PlanetsBlock); ok {
				planetCount := pb.GetPlanetCount()
				if planetCount > 0 {
					planetDataLen := planetCount * 4
					originalOffset := offset
					if originalOffset+planetDataLen <= len(originalData) {
						result = append(result, originalData[originalOffset:originalOffset+planetDataLen]...)
					}
				}
			}
		}
	}

	return result, nil
}

// Modified returns true if the fixer modified any blocks.
func (f *Fixer) Modified() bool {
	return f.modified
}

// FixBytes fixes exploits in file bytes and returns the fixed data.
func FixBytes(filename string, data []byte) ([]byte, *Result, error) {
	fixer := NewFixer()
	return fixer.FixFile(filename, data)
}
