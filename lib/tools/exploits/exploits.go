// Package exploits provides detection and optional fixes for known Stars! exploits.
//
// This package can detect the following exploits:
//   - Cheap Colonizer: Empty colonization slot still allows colonizing
//   - Space Dock Overflow: >21 SuperLatanium causes armor overflow
//   - 10th Starbase: Last player's 10th starbase can crash the game
//   - Friendly Fire: Default battle plan attacking allies
//   - SS Pop Steal: Robber Baron stealing enemy colonists
//   - 32k Merge: Merging fleets exceeding 32,767 ships of one type
//   - Mineral Upload: Uploading minerals to enemy fleet beyond capacity
//   - Cheap Starbase: Editing starbase design while under construction
package exploits

import (
	"fmt"
)

// ExploitType identifies the type of exploit detected.
type ExploitType int

const (
	ExploitCheapColonizer ExploitType = iota
	ExploitSpaceDockOverflow
	ExploitTenthStarbase
	ExploitFriendlyFire
	ExploitSSPopSteal
	Exploit32kMerge
	ExploitMineralUpload
	ExploitCheapStarbase
)

// String returns the human-readable name of the exploit type.
func (e ExploitType) String() string {
	names := []string{
		"Cheap Colonizer",
		"Space Dock Overflow",
		"10th Starbase",
		"Friendly Fire",
		"SS Pop Steal",
		"32k Merge",
		"Mineral Upload",
		"Cheap Starbase",
	}
	if int(e) < len(names) {
		return names[e]
	}
	return fmt.Sprintf("Unknown(%d)", e)
}

// Severity indicates how serious the exploit is.
type Severity int

const (
	SeverityWarning  Severity = iota // Potential issue, but may have legitimate use
	SeverityCritical                 // Definite exploit, should be fixed
	SeverityCrash                    // Can crash the game
)

// String returns the human-readable name of the severity.
func (s Severity) String() string {
	switch s {
	case SeverityWarning:
		return "Warning"
	case SeverityCritical:
		return "Critical"
	case SeverityCrash:
		return "Crash"
	default:
		return "Unknown"
	}
}

// Detection represents a detected exploit instance.
type Detection struct {
	Type        ExploitType // Type of exploit
	Severity    Severity    // How serious is this
	Player      int         // Player index (0-15) who is affected/causing
	Description string      // Human-readable description
	Details     string      // Additional technical details
	CanFix      bool        // True if this detection can be auto-fixed
	BlockIndex  int         // Index of the problematic block (for fixing)
	FixApplied  bool        // True if fix was applied
}

// String returns a formatted string representation of the detection.
func (d *Detection) String() string {
	severity := d.Severity.String()
	fix := ""
	if d.CanFix {
		if d.FixApplied {
			fix = " [FIXED]"
		} else {
			fix = " [fixable]"
		}
	}
	return fmt.Sprintf("[%s] %s: Player %d: %s%s", severity, d.Type, d.Player+1, d.Description, fix)
}

// Result contains all detections from scanning files.
type Result struct {
	Detections []*Detection
}

// NewResult creates a new empty result.
func NewResult() *Result {
	return &Result{
		Detections: make([]*Detection, 0),
	}
}

// Add adds a detection to the result.
func (r *Result) Add(d *Detection) {
	r.Detections = append(r.Detections, d)
}

// HasExploits returns true if any exploits were detected.
func (r *Result) HasExploits() bool {
	return len(r.Detections) > 0
}

// Count returns the number of detected exploits.
func (r *Result) Count() int {
	return len(r.Detections)
}

// CountByType returns the number of detections of a specific type.
func (r *Result) CountByType(t ExploitType) int {
	count := 0
	for _, d := range r.Detections {
		if d.Type == t {
			count++
		}
	}
	return count
}

// CountBySeverity returns the number of detections at a specific severity.
func (r *Result) CountBySeverity(s Severity) int {
	count := 0
	for _, d := range r.Detections {
		if d.Severity == s {
			count++
		}
	}
	return count
}

// FixableCount returns the number of detections that can be fixed.
func (r *Result) FixableCount() int {
	count := 0
	for _, d := range r.Detections {
		if d.CanFix && !d.FixApplied {
			count++
		}
	}
	return count
}

// ByPlayer returns detections for a specific player.
func (r *Result) ByPlayer(player int) []*Detection {
	var result []*Detection
	for _, d := range r.Detections {
		if d.Player == player {
			result = append(result, d)
		}
	}
	return result
}

// ByType returns detections of a specific type.
func (r *Result) ByType(t ExploitType) []*Detection {
	var result []*Detection
	for _, d := range r.Detections {
		if d.Type == t {
			result = append(result, d)
		}
	}
	return result
}
