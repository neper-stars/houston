package exploits

import (
	"fmt"

	"github.com/neper-stars/houston/blocks"
	"github.com/neper-stars/houston/parser"
)

// Scanner scans Stars! files for known exploits.
type Scanner struct {
	// Game state tracking (built from H/M files)
	designs       map[int]map[int]*blocks.DesignBlock       // [player][slot] -> design
	fleets        map[int]map[int]*blocks.PartialFleetBlock // [player][fleet] -> fleet
	battlePlans   map[int]map[int]*blocks.BattlePlanBlock   // [player][plan] -> plan
	productionQ   map[int]map[int][]blocks.QueueItem        // [player][planet] -> queue items
	designChanges map[int]map[int]bool                      // [player][slot] -> changed this turn

	// Game info
	lastPlayer int // Last player index (for 10th starbase check)

	// Detection results
	result *Result
}

// NewScanner creates a new exploit scanner.
func NewScanner() *Scanner {
	return &Scanner{
		designs:       make(map[int]map[int]*blocks.DesignBlock),
		fleets:        make(map[int]map[int]*blocks.PartialFleetBlock),
		battlePlans:   make(map[int]map[int]*blocks.BattlePlanBlock),
		productionQ:   make(map[int]map[int][]blocks.QueueItem),
		designChanges: make(map[int]map[int]bool),
		lastPlayer:    15, // Default to max, will be updated from file
		result:        NewResult(),
	}
}

// ScanFile scans a single file for exploits.
// The file can be an M file (state), X file (orders), or H file (host).
// For best results, scan both the M/H file (for state) and X file (for orders).
func (s *Scanner) ScanFile(filename string, data []byte) error {
	fd := parser.FileData(data)

	header, err := fd.FileHeader()
	if err != nil {
		return fmt.Errorf("failed to get file header: %w", err)
	}

	blockList, err := fd.BlockList()
	if err != nil {
		return fmt.Errorf("failed to parse blocks: %w", err)
	}

	// Note: We don't have direct access to player count from the header
	// The 10th starbase check will use the default lastPlayer value

	// Track player from the file
	playerIndex := 0
	if header != nil {
		playerIndex = header.PlayerIndex()
	}

	// Process blocks based on type
	for i, blk := range blockList {
		switch b := blk.(type) {
		case blocks.DesignBlock:
			s.processDesign(&b, playerIndex, i)

		case *blocks.DesignBlock:
			s.processDesign(b, playerIndex, i)

		case blocks.DesignChangeBlock:
			s.processDesignChange(&b, playerIndex, i)

		case *blocks.DesignChangeBlock:
			s.processDesignChange(b, playerIndex, i)

		case blocks.FleetBlock:
			s.processFleet(&b.PartialFleetBlock)

		case *blocks.FleetBlock:
			s.processFleet(&b.PartialFleetBlock)

		case blocks.PartialFleetBlock:
			s.processFleet(&b)

		case *blocks.PartialFleetBlock:
			s.processFleet(b)

		case blocks.BattlePlanBlock:
			s.processBattlePlan(&b, i)

		case *blocks.BattlePlanBlock:
			s.processBattlePlan(b, i)

		case blocks.ProductionQueueBlock:
			s.processProductionQueue(&b, playerIndex)

		case *blocks.ProductionQueueBlock:
			s.processProductionQueue(b, playerIndex)

		case blocks.ProductionQueueChangeBlock:
			s.processProductionQueueChange(&b, playerIndex)

		case *blocks.ProductionQueueChangeBlock:
			s.processProductionQueueChange(b, playerIndex)

		case blocks.WaypointChangeTaskBlock:
			s.processWaypointChangeTask(&b, playerIndex, i)

		case *blocks.WaypointChangeTaskBlock:
			s.processWaypointChangeTask(b, playerIndex, i)
		}
	}

	return nil
}

// processDesign stores design info and checks for design-based exploits.
func (s *Scanner) processDesign(db *blocks.DesignBlock, player int, blockIndex int) {
	// Store the design
	if s.designs[player] == nil {
		s.designs[player] = make(map[int]*blocks.DesignBlock)
	}
	s.designs[player][db.DesignNumber] = db

	// Check for Cheap Colonizer exploit
	if db.ColonizerModuleBug {
		s.result.Add(&Detection{
			Type:        ExploitCheapColonizer,
			Severity:    SeverityCritical,
			Player:      player,
			Description: fmt.Sprintf("Ship design slot %d (%s): empty colonization slot still allows colonizing", db.DesignNumber+1, db.Name),
			Details:     "A colonization module was removed but the slot left empty. The ship can still colonize planets.",
			CanFix:      true,
			BlockIndex:  blockIndex,
		})
	}

	// Check for Space Dock Overflow exploit
	if db.SpaceDocBug {
		s.result.Add(&Detection{
			Type:        ExploitSpaceDockOverflow,
			Severity:    SeverityCritical,
			Player:      player,
			Description: fmt.Sprintf("Starbase design slot %d (%s): >21 SuperLatanium causes armor overflow", db.DesignNumber+1, db.Name),
			Details:     fmt.Sprintf("Space Dock has >21 SuperLatanium resulting in %d armor (should be ~16000 max).", db.Armor),
			CanFix:      true,
			BlockIndex:  blockIndex,
		})
	}

	// Check for 10th Starbase (warning only for last player)
	if db.IsStarbase && db.DesignNumber == 9 && player == s.lastPlayer {
		s.result.Add(&Detection{
			Type:        ExploitTenthStarbase,
			Severity:    SeverityCrash,
			Player:      player,
			Description: fmt.Sprintf("Starbase (%s) in design slot 10", db.Name),
			Details:     "If Player 1 Fleet 1 refuels at last player's 10th starbase design, the game may crash.",
			CanFix:      false, // Cannot auto-fix - game engine bug
			BlockIndex:  blockIndex,
		})
	}
}

// processDesignChange checks for design change exploits.
func (s *Scanner) processDesignChange(dcb *blocks.DesignChangeBlock, player int, blockIndex int) {
	if dcb.IsDelete {
		// Deletion - clear any Cheap Starbase warnings for this design
		return
	}

	if dcb.Design == nil {
		return
	}

	db := dcb.Design
	owner := player

	// Track that this design was changed
	if s.designChanges[owner] == nil {
		s.designChanges[owner] = make(map[int]bool)
	}
	s.designChanges[owner][db.DesignNumber] = true

	// Check for Cheap Colonizer in design change
	if db.ColonizerModuleBug {
		s.result.Add(&Detection{
			Type:        ExploitCheapColonizer,
			Severity:    SeverityCritical,
			Player:      owner,
			Description: fmt.Sprintf("Ship design change slot %d (%s): empty colonization slot", db.DesignNumber+1, db.Name),
			Details:     "A colonization module was removed but the slot left empty.",
			CanFix:      true,
			BlockIndex:  blockIndex,
		})
	}

	// Check for Space Dock Overflow in design change
	if db.SpaceDocBug {
		s.result.Add(&Detection{
			Type:        ExploitSpaceDockOverflow,
			Severity:    SeverityCritical,
			Player:      owner,
			Description: fmt.Sprintf("Starbase design change slot %d (%s): armor overflow", db.DesignNumber+1, db.Name),
			Details:     fmt.Sprintf("Space Dock has >21 SuperLatanium resulting in %d armor.", db.Armor),
			CanFix:      true,
			BlockIndex:  blockIndex,
		})
	}

	// Check for Cheap Starbase exploit (editing starbase under construction)
	if db.IsStarbase && db.TotalBuilt == 0 {
		// Check if this design is in a production queue with partial completion
		if s.checkCheapStarbase(owner, db.DesignNumber) {
			s.result.Add(&Detection{
				Type:        ExploitCheapStarbase,
				Severity:    SeverityCritical,
				Player:      owner,
				Description: fmt.Sprintf("Editing starbase design slot %d (%s) while under construction", db.DesignNumber+1, db.Name),
				Details:     "Editing a starbase that is partially built allows getting components at a fraction of the cost.",
				CanFix:      true,
				BlockIndex:  blockIndex,
			})
		}
	}
}

// checkCheapStarbase checks if a design is partially built in a production queue.
func (s *Scanner) checkCheapStarbase(player int, designSlot int) bool {
	queues, ok := s.productionQ[player]
	if !ok {
		return false
	}

	for _, items := range queues {
		for _, item := range items {
			// ItemType 4 = ship/starbase design
			if item.ItemType == 4 && item.ItemId == designSlot && item.CompletePercent > 0 {
				return true
			}
		}
	}
	return false
}

// processFleet stores fleet info for merge checking.
func (s *Scanner) processFleet(fb *blocks.PartialFleetBlock) {
	if s.fleets[fb.Owner] == nil {
		s.fleets[fb.Owner] = make(map[int]*blocks.PartialFleetBlock)
	}
	s.fleets[fb.Owner][fb.FleetNumber] = fb
}

// processBattlePlan checks for Friendly Fire exploit.
func (s *Scanner) processBattlePlan(bp *blocks.BattlePlanBlock, blockIndex int) {
	// Store the plan
	if s.battlePlans[bp.OwnerPlayerId] == nil {
		s.battlePlans[bp.OwnerPlayerId] = make(map[int]*blocks.BattlePlanBlock)
	}
	s.battlePlans[bp.OwnerPlayerId][bp.PlanId] = bp

	// Friendly Fire check: Default battle plan (plan 0) targeting specific players
	// AttackWho > 3 means attacking specific players instead of enemies
	if bp.PlanId == 0 && bp.AttackWho > 3 && !bp.Deleted {
		targetPlayer := bp.AttackWho - blocks.AttackPlayerBase
		s.result.Add(&Detection{
			Type:        ExploitFriendlyFire,
			Severity:    SeverityCritical,
			Player:      bp.OwnerPlayerId,
			Description: fmt.Sprintf("Default battle plan attacks player %d", targetPlayer+1),
			Details:     "Default battle plan configured to attack specific player, causing friendly fire in allied battles.",
			CanFix:      true,
			BlockIndex:  blockIndex,
		})
	}
}

// processProductionQueue stores queue data for Cheap Starbase detection.
// Note: ProductionQueueBlock doesn't have PlanetId, so we use a simple counter.
func (s *Scanner) processProductionQueue(pq *blocks.ProductionQueueBlock, player int) {
	if s.productionQ[player] == nil {
		s.productionQ[player] = make(map[int][]blocks.QueueItem)
	}
	// Use a simple counter since ProductionQueueBlock doesn't have PlanetId
	planetId := len(s.productionQ[player])
	s.productionQ[player][planetId] = pq.Items
}

// processProductionQueueChange stores queue data from change blocks.
func (s *Scanner) processProductionQueueChange(pqc *blocks.ProductionQueueChangeBlock, player int) {
	if s.productionQ[player] == nil {
		s.productionQ[player] = make(map[int][]blocks.QueueItem)
	}
	s.productionQ[player][pqc.PlanetId] = pqc.Items

	// Check if any partially built items have their design changed
	for _, item := range pqc.Items {
		if item.ItemType == 4 && item.CompletePercent > 0 {
			// Check if this design was changed
			if changed, ok := s.designChanges[player]; ok && changed[item.ItemId] {
				s.result.Add(&Detection{
					Type:        ExploitCheapStarbase,
					Severity:    SeverityCritical,
					Player:      player,
					Description: fmt.Sprintf("Design slot %d edited while %d%% complete on planet %d", item.ItemId+1, item.CompletePercent/10, pqc.PlanetId+1),
					Details:     "Editing a design that is partially built allows getting components at a fraction of the cost.",
					CanFix:      true,
				})
			}
		}
	}
}

// processWaypointChangeTask checks for waypoint-based exploits.
func (s *Scanner) processWaypointChangeTask(wct *blocks.WaypointChangeTaskBlock, player int, blockIndex int) {
	// SS Pop Steal check: Transport task with population load on a fleet with Robber Baron
	// Target type 1 = planet, task 1 = transport
	if wct.WaypointTask == blocks.WaypointTaskTransport && wct.TargetType == blocks.WaypointTargetPlanet {
		// Check if colonist transport has a load action (1, 3, 5, 6, 7, 9)
		popAction := wct.TransportOrders[blocks.CargoColonists].Action
		if popAction == 1 || popAction == 3 || popAction == 5 || popAction == 6 || popAction == 7 || popAction == 9 {
			// Check if fleet has Robber Baron capability
			if s.fleetHasRobberBaron(player, wct.FleetNumber) {
				s.result.Add(&Detection{
					Type:        ExploitSSPopSteal,
					Severity:    SeverityCritical,
					Player:      player,
					Description: fmt.Sprintf("Fleet %d: Transport population orders with Robber Baron", wct.FleetNumber+1),
					Details: fmt.Sprintf("Fleet with Robber Baron assigned %s colonist orders at (%d, %d).",
						blocks.TransportTaskName(popAction), wct.X, wct.Y),
					CanFix:     true,
					BlockIndex: blockIndex,
				})
			}
		}
	}

	// 32k Merge check: Merge task that would exceed 32,767 ships
	if wct.WaypointTask == blocks.WaypointTaskMergeFleet && wct.TargetType == blocks.WaypointTargetFleet {
		sourceFleet := s.getFleet(player, wct.FleetNumber)
		targetFleet := s.getFleet(player, wct.Target)

		if sourceFleet != nil && targetFleet != nil {
			// Check if any ship type would exceed 32,767
			for slot := 0; slot < 16; slot++ {
				combined := sourceFleet.ShipCount[slot] + targetFleet.ShipCount[slot]
				if combined > 32767 {
					s.result.Add(&Detection{
						Type:        Exploit32kMerge,
						Severity:    SeverityCritical,
						Player:      player,
						Description: fmt.Sprintf("Fleet %d merging with Fleet %d exceeds 32k ships", wct.FleetNumber+1, wct.Target+1),
						Details: fmt.Sprintf("Design slot %d: %d + %d = %d ships (max 32,767).",
							slot+1, sourceFleet.ShipCount[slot], targetFleet.ShipCount[slot], combined),
						CanFix:     true,
						BlockIndex: blockIndex,
					})
					break // Only report once per merge
				}
			}
		}
	}
}

// fleetHasRobberBaron checks if a fleet has Robber Baron capability.
// This requires knowing the fleet's ship designs, which may not always be available.
func (s *Scanner) fleetHasRobberBaron(player, fleetNumber int) bool {
	fleet := s.getFleet(player, fleetNumber)
	if fleet == nil {
		return false
	}

	// Check each design in the fleet
	designs := s.designs[player]
	if designs == nil {
		return false
	}

	for slot := 0; slot < 16; slot++ {
		if (fleet.ShipTypes & (1 << slot)) == 0 {
			continue
		}

		design, ok := designs[slot]
		if !ok {
			continue
		}

		// Check if any slot contains a Robber Baron scanner
		// Category 2 = Scanners, ItemId 5 = Robber Baron
		for _, ds := range design.Slots {
			if ds.Category == 2 && ds.ItemId == 5 {
				return true
			}
		}
	}

	return false
}

// getFleet returns the fleet data for a player's fleet.
func (s *Scanner) getFleet(player, fleetNumber int) *blocks.PartialFleetBlock {
	if s.fleets[player] == nil {
		return nil
	}
	return s.fleets[player][fleetNumber]
}

// Result returns the scan result.
func (s *Scanner) Result() *Result {
	return s.result
}

// ScanFiles scans multiple files and returns combined results.
func ScanFiles(files map[string][]byte) (*Result, error) {
	scanner := NewScanner()

	for filename, data := range files {
		if err := scanner.ScanFile(filename, data); err != nil {
			return nil, fmt.Errorf("error scanning %s: %w", filename, err)
		}
	}

	return scanner.Result(), nil
}

// ScanBytes scans a single file from bytes.
func ScanBytes(filename string, data []byte) (*Result, error) {
	scanner := NewScanner()
	if err := scanner.ScanFile(filename, data); err != nil {
		return nil, err
	}
	return scanner.Result(), nil
}
