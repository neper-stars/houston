package exploits

import (
	"os"
	"path/filepath"
	"testing"
)

func TestScanBytes_NoExploits(t *testing.T) {
	// Test with a known clean file
	testFile := "../../../testdata/scenario-basic/game.m1"
	data, err := os.ReadFile(testFile)
	if err != nil {
		t.Skipf("Test file not found: %s", testFile)
	}

	result, err := ScanBytes(testFile, data)
	if err != nil {
		t.Fatalf("ScanBytes failed: %v", err)
	}

	// This file should have no exploits
	if result.HasExploits() {
		for _, d := range result.Detections {
			t.Logf("Detected: %s", d)
		}
	}
}

func TestScanBytes_AllTestFiles(t *testing.T) {
	patterns := []string{
		"../../../testdata/**/*.m[0-9]",
		"../../../testdata/**/*.m1[0-6]",
		"../../../testdata/**/*.x[0-9]",
		"../../../testdata/**/*.x1[0-6]",
		"../../../testdata/**/*.xy",
	}

	var files []string
	for _, p := range patterns {
		matches, _ := filepath.Glob(p)
		files = append(files, matches...)
	}

	if len(files) == 0 {
		t.Skip("No test files found")
	}

	for _, file := range files {
		t.Run(filepath.Base(file), func(t *testing.T) {
			data, err := os.ReadFile(file)
			if err != nil {
				t.Fatalf("Failed to read file: %v", err)
			}

			result, err := ScanBytes(file, data)
			if err != nil {
				t.Fatalf("ScanBytes failed: %v", err)
			}

			// Log any detections (for info purposes)
			if result.HasExploits() {
				for _, d := range result.Detections {
					t.Logf("Detected in %s: %s", file, d)
				}
			}
		})
	}
}

func TestExploitType_String(t *testing.T) {
	tests := []struct {
		exploit ExploitType
		want    string
	}{
		{ExploitCheapColonizer, "Cheap Colonizer"},
		{ExploitSpaceDockOverflow, "Space Dock Overflow"},
		{ExploitTenthStarbase, "10th Starbase"},
		{ExploitFriendlyFire, "Friendly Fire"},
		{ExploitSSPopSteal, "SS Pop Steal"},
		{Exploit32kMerge, "32k Merge"},
		{ExploitMineralUpload, "Mineral Upload"},
		{ExploitCheapStarbase, "Cheap Starbase"},
	}

	for _, tt := range tests {
		t.Run(tt.want, func(t *testing.T) {
			if got := tt.exploit.String(); got != tt.want {
				t.Errorf("String() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestSeverity_String(t *testing.T) {
	tests := []struct {
		severity Severity
		want     string
	}{
		{SeverityWarning, "Warning"},
		{SeverityCritical, "Critical"},
		{SeverityCrash, "Crash"},
	}

	for _, tt := range tests {
		t.Run(tt.want, func(t *testing.T) {
			if got := tt.severity.String(); got != tt.want {
				t.Errorf("String() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestResult_Helpers(t *testing.T) {
	result := NewResult()

	// Empty result
	if result.HasExploits() {
		t.Error("Expected no exploits in empty result")
	}
	if result.Count() != 0 {
		t.Errorf("Expected count 0, got %d", result.Count())
	}

	// Add some detections
	result.Add(&Detection{
		Type:     ExploitCheapColonizer,
		Severity: SeverityCritical,
		Player:   0,
		CanFix:   true,
	})
	result.Add(&Detection{
		Type:     ExploitFriendlyFire,
		Severity: SeverityCritical,
		Player:   1,
		CanFix:   true,
	})
	result.Add(&Detection{
		Type:     ExploitTenthStarbase,
		Severity: SeverityCrash,
		Player:   0,
		CanFix:   false,
	})

	if !result.HasExploits() {
		t.Error("Expected exploits in result")
	}
	if result.Count() != 3 {
		t.Errorf("Expected count 3, got %d", result.Count())
	}
	if result.CountByType(ExploitCheapColonizer) != 1 {
		t.Errorf("Expected 1 cheap colonizer, got %d", result.CountByType(ExploitCheapColonizer))
	}
	if result.CountBySeverity(SeverityCritical) != 2 {
		t.Errorf("Expected 2 critical, got %d", result.CountBySeverity(SeverityCritical))
	}
	if result.FixableCount() != 2 {
		t.Errorf("Expected 2 fixable, got %d", result.FixableCount())
	}

	player0 := result.ByPlayer(0)
	if len(player0) != 2 {
		t.Errorf("Expected 2 for player 0, got %d", len(player0))
	}

	crashes := result.ByType(ExploitTenthStarbase)
	if len(crashes) != 1 {
		t.Errorf("Expected 1 10th starbase, got %d", len(crashes))
	}
}

func TestDetection_String(t *testing.T) {
	d := &Detection{
		Type:        ExploitCheapColonizer,
		Severity:    SeverityCritical,
		Player:      0,
		Description: "Test description",
		CanFix:      true,
	}

	s := d.String()
	if s == "" {
		t.Error("Detection.String() returned empty string")
	}

	// Check it contains expected parts
	if !contains(s, "Critical") {
		t.Error("Expected string to contain 'Critical'")
	}
	if !contains(s, "Cheap Colonizer") {
		t.Error("Expected string to contain 'Cheap Colonizer'")
	}
	if !contains(s, "Player 1") {
		t.Error("Expected string to contain 'Player 1'")
	}
}

func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > 0 && (s[:len(substr)] == substr || contains(s[1:], substr)))
}
