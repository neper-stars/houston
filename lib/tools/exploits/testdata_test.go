package exploits

import (
	"encoding/binary"
	"os"
	"testing"

	"github.com/neper-stars/houston/blocks"
	"github.com/neper-stars/houston/crypto"
	"github.com/neper-stars/houston/parser"
)

// modifiedBlock holds a block with potentially modified decrypted data
type modifiedBlock struct {
	typeID    blocks.BlockTypeID
	rawData   []byte
	decrypted []byte
}

// TestCreateAndDetectFriendlyFire creates a file with the Friendly Fire exploit
// and verifies it's detected.
func TestCreateAndDetectFriendlyFire(t *testing.T) {
	testFile := "../../../testdata/scenario-battleplans/game.m2"
	data, err := os.ReadFile(testFile)
	if err != nil {
		t.Skipf("Test file not found: %s", testFile)
	}

	fd := parser.FileData(data)
	header, err := fd.FileHeader()
	if err != nil {
		t.Fatalf("Failed to get header: %v", err)
	}

	blockList, err := fd.BlockList()
	if err != nil {
		t.Fatalf("Failed to parse blocks: %v", err)
	}

	// Convert to modifiable blocks
	modBlocks := make([]modifiedBlock, len(blockList))
	for i, blk := range blockList {
		decrypted := make([]byte, len(blk.DecryptedData()))
		copy(decrypted, blk.DecryptedData())
		modBlocks[i] = modifiedBlock{
			typeID:    blk.BlockTypeID(),
			rawData:   blk.BlockData(),
			decrypted: decrypted,
		}
	}

	// Find and modify the default battle plan
	modified := false
	for i := range modBlocks {
		if modBlocks[i].typeID == blocks.BattlePlanBlockType {
			decrypted := modBlocks[i].decrypted
			if len(decrypted) >= 4 {
				// Check if this is plan 0 (bits 4-7 of byte 0-1)
				word0 := binary.LittleEndian.Uint16(decrypted[0:2])
				planId := (word0 >> 4) & 0x0F
				if planId == 0 {
					// Modify AttackWho (byte 3) to attack a specific player
					decrypted[3] = 5 // AttackPlayerBase + 1
					modified = true
					t.Logf("Modified battle plan 0: set AttackWho to %d", decrypted[3])
					break
				}
			}
		}
	}

	if !modified {
		t.Skip("No default battle plan found to modify")
	}

	// Regenerate the file
	exploitData := regenerateModifiedFile(t, data, modBlocks, header)

	// Now scan the modified file
	result, err := ScanBytes("test-friendly-fire.m2", exploitData)
	if err != nil {
		t.Fatalf("ScanBytes failed: %v", err)
	}

	if !result.HasExploits() {
		t.Fatal("Expected to detect Friendly Fire exploit")
	}

	found := false
	for _, d := range result.Detections {
		t.Logf("Detected: %s", d)
		if d.Type == ExploitFriendlyFire {
			found = true
		}
	}

	if !found {
		t.Error("Expected Friendly Fire exploit but got different exploit type")
	}
}

// TestCreateAndDetectCheapColonizer creates a file with the Cheap Colonizer exploit
func TestCreateAndDetectCheapColonizer(t *testing.T) {
	testFile := "../../../testdata/scenario-basic/game.m1"
	data, err := os.ReadFile(testFile)
	if err != nil {
		t.Skipf("Test file not found: %s", testFile)
	}

	fd := parser.FileData(data)
	header, err := fd.FileHeader()
	if err != nil {
		t.Fatalf("Failed to get header: %v", err)
	}

	blockList, err := fd.BlockList()
	if err != nil {
		t.Fatalf("Failed to parse blocks: %v", err)
	}

	modBlocks := make([]modifiedBlock, len(blockList))
	for i, blk := range blockList {
		decrypted := make([]byte, len(blk.DecryptedData()))
		copy(decrypted, blk.DecryptedData())
		modBlocks[i] = modifiedBlock{
			typeID:    blk.BlockTypeID(),
			rawData:   blk.BlockData(),
			decrypted: decrypted,
		}
	}

	// Find a design block with slots and add empty colonizer
	modified := false
	for i := range modBlocks {
		if modBlocks[i].typeID == blocks.DesignBlockType {
			decrypted := modBlocks[i].decrypted
			if len(decrypted) < 17 {
				continue
			}

			// Check if full design (bit 2 of byte 0)
			isFullDesign := (decrypted[0] & 0x04) == 0x04
			if !isFullDesign {
				continue
			}

			// Slot count at byte 6
			slotCount := int(decrypted[6])
			if slotCount == 0 {
				continue
			}

			// Slots start at byte 17
			slotOffset := 17
			if slotOffset+4 <= len(decrypted) {
				// Set first slot to empty colonizer: category=4096, itemId=0, count=0
				binary.LittleEndian.PutUint16(decrypted[slotOffset:], 4096)
				decrypted[slotOffset+2] = 0
				decrypted[slotOffset+3] = 0
				modified = true
				t.Logf("Modified design at slot offset %d: added empty colonizer slot", slotOffset)
				break
			}
		}
	}

	if !modified {
		t.Skip("No suitable design found to modify")
	}

	exploitData := regenerateModifiedFile(t, data, modBlocks, header)

	result, err := ScanBytes("test-cheap-colonizer.m1", exploitData)
	if err != nil {
		t.Fatalf("ScanBytes failed: %v", err)
	}

	if !result.HasExploits() {
		t.Fatal("Expected to detect Cheap Colonizer exploit")
	}

	found := false
	for _, d := range result.Detections {
		t.Logf("Detected: %s", d)
		if d.Type == ExploitCheapColonizer {
			found = true
		}
	}

	if !found {
		t.Error("Expected Cheap Colonizer exploit but got different exploit type")
	}
}

// TestFriendlyFireFix tests that the fix works
func TestFriendlyFireFix(t *testing.T) {
	testFile := "../../../testdata/scenario-battleplans/game.m2"
	data, err := os.ReadFile(testFile)
	if err != nil {
		t.Skipf("Test file not found: %s", testFile)
	}

	fd := parser.FileData(data)
	header, err := fd.FileHeader()
	if err != nil {
		t.Fatalf("Failed to get header: %v", err)
	}

	blockList, err := fd.BlockList()
	if err != nil {
		t.Fatalf("Failed to parse blocks: %v", err)
	}

	modBlocks := make([]modifiedBlock, len(blockList))
	for i, blk := range blockList {
		decrypted := make([]byte, len(blk.DecryptedData()))
		copy(decrypted, blk.DecryptedData())
		modBlocks[i] = modifiedBlock{
			typeID:    blk.BlockTypeID(),
			rawData:   blk.BlockData(),
			decrypted: decrypted,
		}
	}

	// Create the exploit
	for i := range modBlocks {
		if modBlocks[i].typeID == blocks.BattlePlanBlockType {
			decrypted := modBlocks[i].decrypted
			if len(decrypted) >= 4 {
				word0 := binary.LittleEndian.Uint16(decrypted[0:2])
				planId := (word0 >> 4) & 0x0F
				if planId == 0 {
					decrypted[3] = 5
					break
				}
			}
		}
	}

	exploitData := regenerateModifiedFile(t, data, modBlocks, header)

	// Now fix it
	fixedData, result, err := FixBytes("test.m2", exploitData)
	if err != nil {
		t.Fatalf("FixBytes failed: %v", err)
	}

	// Check that fix was applied
	fixApplied := false
	for _, d := range result.Detections {
		if d.Type == ExploitFriendlyFire && d.FixApplied {
			fixApplied = true
			t.Logf("Fix applied: %s", d)
		}
	}

	if !fixApplied {
		t.Error("Expected fix to be applied for Friendly Fire")
	}

	// Scan the fixed file - should have no Friendly Fire exploits
	result2, err := ScanBytes("fixed.m2", fixedData)
	if err != nil {
		t.Fatalf("ScanBytes on fixed file failed: %v", err)
	}

	for _, d := range result2.Detections {
		if d.Type == ExploitFriendlyFire {
			t.Errorf("Friendly Fire exploit still present after fix: %s", d)
		}
	}
}

// TestScanXFileWithMFileContext demonstrates scanning an X file for exploits
// that require M file context (like 32k Merge which needs fleet ship counts).
// This is how a host would scan player order files.
func TestScanXFileWithMFileContext(t *testing.T) {
	// First, load the M file to get fleet/design context
	mFile := "../../../testdata/scenario-orders/waypoint-merge/game.m1"
	mData, err := os.ReadFile(mFile)
	if err != nil {
		t.Skipf("M file not found: %s", mFile)
	}

	// Then load the X file
	xFile := "../../../testdata/scenario-orders/waypoint-merge/game.x1"
	xData, err := os.ReadFile(xFile)
	if err != nil {
		t.Skipf("X file not found: %s", xFile)
	}

	// Create a scanner and scan M file first to build context
	scanner := NewScanner()

	// Scan M file to populate fleet/design info
	if err := scanner.ScanFile(mFile, mData); err != nil {
		t.Fatalf("Failed to scan M file: %v", err)
	}

	// Now scan X file - it will use the context from M file
	if err := scanner.ScanFile(xFile, xData); err != nil {
		t.Fatalf("Failed to scan X file: %v", err)
	}

	result := scanner.Result()
	t.Logf("Scanned M+X files, found %d detections", result.Count())
	for _, d := range result.Detections {
		t.Logf("  %s", d)
	}

	// This test verifies the scanning works, not that specific exploits are found
	// (since the test files don't contain actual exploits)
}

// regenerateModifiedFile regenerates a file with modified blocks
func regenerateModifiedFile(t *testing.T, originalData []byte, modBlocks []modifiedBlock, header *blocks.FileHeader) []byte {
	t.Helper()

	var result []byte
	originalOffset := 0

	// Initialize encryptor once - it maintains state across blocks
	var encryptor *crypto.Encryptor
	encryptorInitialized := false

	for _, mb := range modBlocks {
		typeID := mb.typeID
		decrypted := mb.decrypted

		switch typeID {
		case blocks.FileHeaderBlockType:
			// Header is not encrypted - use raw data length for block header
			blockHeader := (uint16(typeID) << 10) | uint16(len(mb.rawData))
			result = append(result, byte(blockHeader), byte(blockHeader>>8))
			result = append(result, mb.rawData...)

			// Initialize encryptor from header for subsequent blocks
			if header != nil {
				var sw int
				if header.Crippled() {
					sw = 1
				}
				encryptor = crypto.NewEncryptor()
				encryptor.InitEncryption(header.Salt(), int(header.GameID), int(header.Turn), header.PlayerIndex(), sw)
				encryptorInitialized = true
			}
		case blocks.FileFooterBlockType:
			// Footer is not encrypted
			blockHeader := (uint16(typeID) << 10) | uint16(len(mb.rawData))
			result = append(result, byte(blockHeader), byte(blockHeader>>8))
			result = append(result, mb.rawData...)
		default:
			// Regular blocks - use decrypted length for block header
			blockHeader := (uint16(typeID) << 10) | uint16(len(decrypted))
			result = append(result, byte(blockHeader), byte(blockHeader>>8))
			// Encrypt the (possibly modified) decrypted data
			if encryptorInitialized {
				encrypted := encryptor.EncryptBytes(decrypted)
				result = append(result, encrypted...)
			} else {
				result = append(result, decrypted...)
			}
		}

		originalOffset += 2 + len(mb.rawData)

		// Handle PlanetsBlock extra data
		if typeID == blocks.PlanetsBlockType && len(mb.decrypted) >= 4 {
			// Planet count is at bytes 0-1
			planetCount := int(binary.LittleEndian.Uint16(mb.decrypted[0:2]))
			if planetCount > 0 {
				planetDataLen := planetCount * 4
				if originalOffset+planetDataLen <= len(originalData) {
					result = append(result, originalData[originalOffset:originalOffset+planetDataLen]...)
					originalOffset += planetDataLen
				}
			}
		}
	}

	return result
}
