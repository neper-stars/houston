package main

import (
	"fmt"
	"os"

	"github.com/jessevdk/go-flags"

	"github.com/neper-stars/houston/lib/tools/exploits"
)

type exploitsCommand struct {
	Fix    bool   `short:"f" long:"fix" description:"Apply fixes for detected exploits"`
	Output string `short:"o" long:"output" description:"Output file for fixed data (default: overwrite input)"`
	Args   struct {
		Files []string `positional-arg-name:"FILE" description:"Stars! files to scan (.m, .x, .hst)" required:"1"`
	} `positional-args:"yes"`
}

func (c *exploitsCommand) Execute(args []string) error {
	// Use a shared scanner for all files so M file context is available when scanning X files
	// This allows detecting exploits like 32k Merge that require fleet info from M files
	scanner := exploits.NewScanner()

	// First pass: scan all files to build context
	fileData := make(map[string][]byte)
	for _, filename := range c.Args.Files {
		data, err := os.ReadFile(filename)
		if err != nil {
			return fmt.Errorf("failed to read %s: %w", filename, err)
		}
		fileData[filename] = data

		if err := scanner.ScanFile(filename, data); err != nil {
			return fmt.Errorf("failed to scan %s: %w", filename, err)
		}
	}

	result := scanner.Result()

	if c.Fix {
		// Fix mode: apply fixes to each file that has exploits
		for _, filename := range c.Args.Files {
			data := fileData[filename]
			fixedData, fileResult, err := exploits.FixBytes(filename, data)
			if err != nil {
				return fmt.Errorf("failed to fix %s: %w", filename, err)
			}

			printResult(filename, fileResult)

			if fileResult.FixableCount() > 0 || (fileResult.HasExploits() && anyFixed(fileResult)) {
				outputFile := c.Output
				if outputFile == "" {
					outputFile = filename
				}

				if err := os.WriteFile(outputFile, fixedData, 0644); err != nil {
					return fmt.Errorf("failed to write %s: %w", outputFile, err)
				}
				fmt.Printf("  Wrote fixed file to: %s\n", outputFile)
			}
		}
	} else {
		// Scan mode: report combined results
		if !result.HasExploits() {
			fmt.Printf("No exploits detected in %d file(s)\n", len(c.Args.Files))
		} else {
			fmt.Printf("%d exploit(s) detected across %d file(s):\n", result.Count(), len(c.Args.Files))
			for _, d := range result.Detections {
				fmt.Printf("  %s\n", d)
			}
			printSummary(result)
		}
	}

	return nil
}

func printResult(filename string, result *exploits.Result) {
	if !result.HasExploits() {
		fmt.Printf("%s: No exploits detected\n", filename)
		return
	}

	fmt.Printf("%s: %d exploit(s) detected\n", filename, result.Count())
	for _, d := range result.Detections {
		fmt.Printf("  %s\n", d)
	}

	printSummary(result)
}

func printSummary(result *exploits.Result) {
	critical := result.CountBySeverity(exploits.SeverityCritical)
	crash := result.CountBySeverity(exploits.SeverityCrash)
	warning := result.CountBySeverity(exploits.SeverityWarning)
	fixable := result.FixableCount()

	if critical > 0 || crash > 0 || warning > 0 {
		fmt.Printf("  Summary: ")
		parts := []string{}
		if crash > 0 {
			parts = append(parts, fmt.Sprintf("%d crash", crash))
		}
		if critical > 0 {
			parts = append(parts, fmt.Sprintf("%d critical", critical))
		}
		if warning > 0 {
			parts = append(parts, fmt.Sprintf("%d warning", warning))
		}
		for i, p := range parts {
			if i > 0 {
				fmt.Printf(", ")
			}
			fmt.Printf("%s", p)
		}
		if fixable > 0 {
			fmt.Printf(" (%d fixable)", fixable)
		}
		fmt.Println()
	}
}

func anyFixed(result *exploits.Result) bool {
	for _, d := range result.Detections {
		if d.FixApplied {
			return true
		}
	}
	return false
}

func addExploitsCommand(parser *flags.Parser) {
	_, err := parser.AddCommand("exploits",
		"Detect and fix known exploits",
		"Scans Stars! files for known exploits and optionally fixes them.\n\n"+
			"Detected exploits:\n"+
			"  - Cheap Colonizer: Empty colonization slot still allows colonizing\n"+
			"  - Space Dock Overflow: >21 SuperLatanium causes armor overflow\n"+
			"  - 10th Starbase: Last player's 10th starbase can crash the game\n"+
			"  - Friendly Fire: Default battle plan attacking allies\n"+
			"  - SS Pop Steal: Robber Baron stealing enemy colonists\n"+
			"  - 32k Merge: Merging fleets exceeding 32,767 ships\n"+
			"  - Mineral Upload: Uploading minerals to enemy fleet beyond capacity\n"+
			"  - Cheap Starbase: Editing starbase design while under construction\n\n"+
			"To scan order files (X files), include the matching M file first to\n"+
			"provide fleet/design context for detecting order-based exploits:\n"+
			"  houston exploits game.m1 game.x1\n\n"+
			"Use --fix to automatically apply fixes where possible.",
		&exploitsCommand{})
	if err != nil {
		panic(err)
	}
}
